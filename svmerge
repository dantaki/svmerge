#!/usr/bin/perl
use strict; use warnings;
my $usage='
Tool:     svmerge 
About:    Merge SVs according to reciprocal overlap

Usage:    svmerge <bed file> [overlap]

Required Arguments:
    bed file        bed file of SVs to merge. Can be bgzipped

Optional Arguments:
    overlap         minimum reciprocal overlap requirement [default 0.8]

Notes:
    svmerge takes a bed file as input and merges SVs according to a defined
    minimum reciprocal overlap. 

    svmerge requires bedtools to be in the environment path.

    svmerge is written for UNIX systems with

    This process will create tempory files in the current working directory. 
    Output will be in the form of a chain file linking the consensus SV to 
    the merged position.

    bed_file_svmerged.bed: consensus SV ---> merged SV 

Author:
    Danny Antaki, <dantaki at ucsd dot edu>
';

my $bed = $ARGV[0];
die "FATAL ERROR: bed file required.\n$usage\n"if(! defined $bed);
my $ovr= $ARGV[1];
$ovr=0.8 if(! defined $ovr);
die "FATAL ERROR: overlap must be a float between 0 and 1.\n$usage\n" if($ovr <=0 || $ovr > 1);

# tmp dir
my $tmp_dir = "svmerge_tmp/";
my $tmp_bed = "${tmp_dir}tmp.bed";
system("mkdir -p $tmp_dir");

# write positions to temp bed file
my $cmd = "less $bed | cut -f 1-3 >$tmp_bed";
$cmd = "gunzip -c $bed | cut -f 1-3 >$tmp_bed" if($bed =~ /\.gz$/);
system($cmd);

# intersect SVs
undef my %int;
open IN, "bedtools intersect -a $tmp_bed -b $tmp_bed -F $ovr -f $ovr -wao |";
while(<IN>){
	chomp;
	my @r = split /\t/, $_;
	my $k1 = join "\t", @r[0 .. 2];
	my $k2 = join "\t", @r[3 .. 5];
	$int{$k1}{$k2}++;
}close IN;

reporter(">>> finished intersecting bed file <<<");

system("rm -fr $tmp_dir");

# two pass method ensures only unique positions are merged
undef my %ovr;
undef my %chrom;
foreach my $k1 ( keys %int){
	my($chrom,$s,$e) = split /\t/, $k1;
	$chrom{$chrom}++;
	
	foreach my $k2 (keys %{$int{$k1}}){
		push @{$ovr{$chrom}{$k1}},$k2; # hash of arrays
	}
}

# merge according to most overlapped
undef my %merged;
my $obed = $bed; 
$obed =~ s/\.bed/\.svmerged\.bed/;
$obed =~ s/\.gz$//;
open OUT, ">$obed";

# keys are the number of candidate consensus svs
foreach my $chrom (keys %chrom){

	my $keys = keys %{$ovr{$chrom}};

	#reporter(">>> $chrom\: $keys candidate consensus SVs to merge <<<");

	do {
		#reporter(">>> $keys candidate consensus SVs to merge <<<");

		undef my %to_delete;
		# always start with the SV with the most number of intesects
		foreach my $k1 (sort { 		scalar(@{$ovr{$chrom}{$b}}) 
								<=> scalar(@{$ovr{$chrom}{$a}}) } keys %{$ovr{$chrom}}) {
		
			# delete the consensus sv at a later step
			$to_delete{$k1}++;
		
			foreach my $k2 (@{$ovr{$chrom}{$k1}}){
				print OUT "$k1\t$k2\n";
				# delete the merged SVs 
				$to_delete{$k2}++;
			}
			# only process one SV at a time in the do/while loop
			last;
		}

		# iterate through the list of overlaps again
		# remove svs that have been merged above
		foreach my $k1 (keys %{$ovr{$chrom}}){
			undef my @new;
			foreach my $k2 (@{$ovr{$chrom}{$k1}}){
				push @new, $k2 if(! exists $to_delete{$k2});
			}

			# re-define the array of overlaps with SVs that have
			# yet to be merged
			@{$ovr{$chrom}{$k1}}=@new;
		}

		# delete candidate consensus SVs that have already been merged
		foreach my $k1 (keys %to_delete){
			delete $ovr{$chrom}{$k1} if(exists $ovr{$chrom}{$k1});
		}

		# get the number of remaining consensus svs
		$keys = keys %{$ovr{$chrom}};

	} until($keys==0);
}

reporter(">>> output ---> $obed <<<");

##############
sub reporter {
	my $s = shift @_;
	warn "\n    $s\n";
}